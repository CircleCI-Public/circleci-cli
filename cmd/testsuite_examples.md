# Testsuite Init Command - Examples

This document shows example configurations generated by the `circleci testsuite init` command for different test frameworks.

## Example 1: Jest with Test Impact Analysis

```yaml
name: frontend tests
discover: jest --listTests
run: JEST_JUNIT_OUTPUT_FILE="<< outputs.junit >>" jest --runInBand --reporters=jest-junit --bail << test.atoms >>
analysis: jest --runInBand --silent --coverage --coverageProvider=v8 --coverageReporters=lcovonly --coverage-directory="$(dirname << outputs.lcov >>)" --bail << test.atoms >> && cat "$(dirname << outputs.lcov >>)"/*.info > << outputs.lcov >>
outputs:
  junit: test-reports/junit.xml
  lcov: test-reports/lcov.info
options:
  adaptive-testing: true
  test-analysis-duration: 15
  full-test-run-paths:
    - .circleci/*.yml
    - go.mod
    - go.sum
    - package-lock.json
    - package.json
    - project.clj
    - yarn.lock
```

## Example 2: Vitest (Basic Setup, No Test Impact Analysis)

```yaml
name: ci tests
discover: vitest list --filesOnly
run: vitest run --reporter=junit --outputFile="<< outputs.junit >>" --bail 0 << test.atoms >>
outputs:
  junit: test-reports/junit.xml
options:
  full-test-run-paths:
    - .circleci/*.yml
    - package-lock.json
    - package.json
    - yarn.lock
```

## Example 3: Go with gotestsum (with file-mapper)

This example shows the `file-mapper` option, which is needed when test atoms are not file names. In Go, test atoms are packages (e.g., `github.com/myorg/myrepo/pkg/foo`), so a file-mapper maps each package to its actual test files.

```yaml
name: go tests
discover: go list -f '{{ if or (len .TestGoFiles) (len .XTestGoFiles) }} {{ .ImportPath }} {{end}}' ./...
run: go tool gotestsum --junitfile="<< outputs.junit >>" -- -race -count=1 << test.atoms >>
analysis: go tool gotestsum -- -coverprofile="<< outputs.go-coverage >>" -cover -coverpkg ./... << test.atoms >>
file-mapper: go list -f '{{range .TestGoFiles}}{{$.Dir}}/{{.}}{{"\n"}}{{end}}{{range .XTestGoFiles}}{{$.Dir}}/{{.}}{{"\n"}}{{end}}' << test.atoms >>
outputs:
  junit: test-reports/junit.xml
  go-coverage: test-reports/go-coverage.txt
options:
  adaptive-testing: true
  test-analysis-duration: 10
  full-test-run-paths:
    - .circleci/*.yml
    - go.mod
    - go.sum
```

**Note:** The `file-mapper` is only needed when test atoms are not file names. For frameworks like Jest, Vitest, and pytest where test atoms are file paths, you don't need a file-mapper.

## Example 4: Python pytest with Custom Impact Key

```yaml
name: backend tests
discover: pytest --collect-only -qq | sed 's/:.*//' | sort -u
run: pytest --disable-pytest-warnings --no-header --quiet --tb=short --junit-xml="<< outputs.junit >>" << test.atoms >>
analysis: pytest --disable-pytest-warnings --no-header --quiet --tb=short --cov --cov-report=lcov:<< outputs.lcov >> << test.atoms >>
outputs:
  junit: test-reports/junit.xml
  lcov: test-reports/lcov.info
options:
  adaptive-testing: true
  test-analysis-duration: 20
  impact-key: backend-service
  full-test-run-paths:
    - .circleci/*.yml
    - requirements.txt
    - setup.py
```

## Example 5: Multiple Test Suites in One Repository

```yaml
name: frontend tests
discover: vitest list --filesOnly
run: vitest run --reporter=junit --outputFile="<< outputs.junit >>" --bail 0 << test.atoms >>
analysis: vitest run --coverage.enabled --coverage.all=false --coverage.reporter=lcov --coverage.provider=v8 --coverage.reportsDirectory="$(dirname << outputs.lcov >>)" --silent --bail 0 << test.atoms >> && cat "$(dirname << outputs.lcov >>)"/*.info > << outputs.lcov >>
outputs:
  junit: test-reports/frontend-junit.xml
  lcov: test-reports/frontend-lcov.info
options:
  adaptive-testing: true
  impact-key: frontend
  full-test-run-paths:
    - .circleci/*.yml
    - package.json
    - yarn.lock
---
name: backend tests
discover: pytest --collect-only -qq | sed 's/:.*//' | sort -u
run: pytest --disable-pytest-warnings --no-header --quiet --tb=short --junit-xml="<< outputs.junit >>" << test.atoms >>
analysis: pytest --disable-pytest-warnings --no-header --quiet --tb=short --cov --cov-report=lcov:<< outputs.lcov >> << test.atoms >>
outputs:
  junit: test-reports/backend-junit.xml
  lcov: test-reports/backend-lcov.info
options:
  adaptive-testing: true
  impact-key: backend
  full-test-run-paths:
    - .circleci/*.yml
    - requirements.txt
    - setup.py
```

## Using the Generated Configuration

After running `circleci testsuite init`, update your `.circleci/config.yml`:

```yaml
version: 2.1

jobs:
  test:
    docker:
      - image: cimg/node:20.0
    parallelism: 4
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: npm ci
      - run:
          name: Run test suite
          command: circleci run testsuite "ci tests"
      - store_test_results:
          path: test-reports

workflows:
  test-workflow:
    jobs:
      - test
```

## Advanced: Branch-Specific Configuration

Run analysis on main branch, selection on feature branches:

```yaml
version: 2.1

jobs:
  test:
    docker:
      - image: cimg/node:20.0
    # Higher parallelism for analysis phase
    parallelism: << pipeline.git.branch == "main" and 10 or 2 >>
    steps:
      - checkout
      - run: npm ci
      - run: circleci run testsuite "ci tests"
      - store_test_results:
          path: test-reports
```

## Testing Locally

Test your configuration before pushing to CI:

```bash
# Run tests locally
circleci run testsuite "ci tests" --local

# Run with test selection disabled (to test discover and run commands)
circleci run testsuite "ci tests" --local --test-selection=none

# Run analysis phase locally
circleci run testsuite "ci tests" --local --test-analysis=impacted
```
